#!/usr/bin/env python3
"""OutputParsers Avan√ßados - Exemplos com LangChain Real
======================================================

Este arquivo demonstra como usar OutputParsers com LangChain real,
incluindo tratamento de erros e valida√ß√£o customizada.

Autor: Tutor LangChain
Data: 2024
"""

from datetime import datetime, timedelta

# Verifica se as depend√™ncias est√£o dispon√≠veis
try:
    from langchain.output_parsers import PydanticOutputParser
    from langchain_core.output_parsers import StrOutputParser
    from langchain_core.prompts import ChatPromptTemplate
    from langchain_openai import ChatOpenAI
    from pydantic import BaseModel, Field, validator
    LANGCHAIN_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è  LangChain n√£o dispon√≠vel. Executando em modo simulado.")
    LANGCHAIN_AVAILABLE = False
    # Fallback para dataclasses quando Pydantic n√£o est√° dispon√≠vel
    from dataclasses import dataclass as BaseModel
    def Field(*args, **kwargs): return None
    def validator(*args, **kwargs): return lambda x: x


# Modelos Pydantic para OutputParsers
class EventInfo(BaseModel):
    """Informa√ß√µes de um evento com data e hora"""

    event_name: str = Field(description="Nome do evento")
    event_date: datetime = Field(description="Data e hora do evento")
    duration_hours: float | None = Field(default=None, description="Dura√ß√£o em horas")
    is_recurring: bool = Field(description="Se o evento √© recorrente")

    @validator("event_date")
    def validate_future_date(cls, v):
        """Valida se a data est√° no futuro"""
        if v < datetime.now():
            raise ValueError("Data do evento deve estar no futuro")
        return v

    def display_info(self) -> str:
        """Exibe informa√ß√µes formatadas do evento"""
        recurring_text = "(Recorrente)" if self.is_recurring else "(√önico)"
        duration_text = f" - Dura√ß√£o: {self.duration_hours}h" if self.duration_hours else ""

        return f"üìÖ {self.event_name} {recurring_text}\n" \
               f"   üìÜ {self.event_date.strftime('%d/%m/%Y √†s %H:%M')}{duration_text}"


class SentimentAnalysis(BaseModel):
    """An√°lise de sentimento com valores booleanos"""

    text: str = Field(description="Texto analisado")
    is_positive: bool = Field(description="Se o sentimento √© positivo")
    is_negative: bool = Field(description="Se o sentimento √© negativo")
    is_neutral: bool = Field(description="Se o sentimento √© neutro")
    contains_urgency: bool = Field(description="Se o texto cont√©m urg√™ncia")
    confidence_score: float = Field(description="N√≠vel de confian√ßa (0-1)", ge=0.0, le=1.0)

    @validator("confidence_score")
    def validate_confidence(cls, v):
        """Valida score de confian√ßa"""
        if not 0.0 <= v <= 1.0:
            raise ValueError("Confian√ßa deve estar entre 0 e 1")
        return v

    def get_sentiment_label(self) -> str:
        """Retorna o label do sentimento predominante"""
        if self.is_positive:
            return "üòä POSITIVO"
        if self.is_negative:
            return "üòû NEGATIVO"
        return "üòê NEUTRO"

    def display_analysis(self) -> str:
        """Exibe an√°lise formatada"""
        urgency_icon = "üö®" if self.contains_urgency else "‚è∞"
        confidence_bar = "‚ñà" * int(self.confidence_score * 10)

        return f"üìù TEXTO: {self.text}\n" \
               f"{self.get_sentiment_label()}\n" \
               f"{urgency_icon} Urg√™ncia: {'Sim' if self.contains_urgency else 'N√£o'}\n" \
               f"üìä Confian√ßa: {confidence_bar} {self.confidence_score:.1%}"


class AppointmentAnalysis(BaseModel):
    """An√°lise de compromissos com datetime e boolean"""

    appointment_date: datetime = Field(description="Data e hora do compromisso")
    is_urgent: bool = Field(description="Se o compromisso √© urgente")
    is_important: bool = Field(description="Se o compromisso √© importante")
    requires_preparation: bool = Field(description="Se requer prepara√ß√£o pr√©via")
    is_online: bool = Field(description="Se √© uma reuni√£o online")
    duration_minutes: int | None = Field(default=None, description="Dura√ß√£o em minutos")

    @validator("appointment_date")
    def validate_appointment_date(cls, v):
        """Valida data do compromisso"""
        if v < datetime.now():
            raise ValueError("Compromisso deve estar no futuro")
        return v

    def get_priority_level(self) -> str:
        """Determina o n√≠vel de prioridade"""
        if self.is_urgent and self.is_important:
            return "üî¥ ALTA PRIORIDADE"
        if self.is_important:
            return "üü° M√âDIA PRIORIDADE"
        return "üü¢ BAIXA PRIORIDADE"

    def display_appointment(self) -> str:
        """Exibe informa√ß√µes do compromisso"""
        online_icon = "üíª" if self.is_online else "üè¢"
        prep_icon = "üìã" if self.requires_preparation else "‚úÖ"
        duration_text = f" ({self.duration_minutes}min)" if self.duration_minutes else ""

        return f"{self.get_priority_level()}\n" \
               f"üìÖ {self.appointment_date.strftime('%d/%m/%Y √†s %H:%M')}{duration_text}\n" \
               f"{online_icon} {'Online' if self.is_online else 'Presencial'}\n" \
               f"{prep_icon} {'Requer prepara√ß√£o' if self.requires_preparation else 'Sem prepara√ß√£o'}"


class TaskInfo(BaseModel):
    """Informa√ß√µes de tarefa com valida√ß√£o complexa"""

    task_name: str = Field(description="Nome da tarefa", min_length=1)
    due_date: datetime = Field(description="Data de vencimento")
    is_completed: bool = Field(description="Se a tarefa est√° completa")
    is_high_priority: bool = Field(description="Se √© alta prioridade")
    estimated_hours: float | None = Field(default=None, description="Horas estimadas", ge=0.0)

    @validator("due_date")
    def validate_future_date(cls, v):
        """Valida se a data est√° no futuro"""
        if v < datetime.now():
            raise ValueError("Data de vencimento deve estar no futuro")
        return v

    @validator("is_completed")
    def validate_completion_logic(cls, v, values):
        """Valida l√≥gica de conclus√£o"""
        if "due_date" in values:
            due_date = values["due_date"]
            if v and due_date > datetime.now():
                print("‚ö†Ô∏è  Aviso: Tarefa marcada como completa antes da data de vencimento")
        return v

    def get_status_icon(self) -> str:
        """Retorna √≠cone baseado no status"""
        if self.is_completed:
            return "‚úÖ"
        if self.is_high_priority:
            return "üî¥"
        return "üü°"

    def display_task(self) -> str:
        """Exibe informa√ß√µes da tarefa"""
        days_until_due = (self.due_date - datetime.now()).days
        status_text = "Conclu√≠da" if self.is_completed else f"Pendente ({days_until_due} dias)"
        priority_text = "Alta Prioridade" if self.is_high_priority else "Prioridade Normal"
        hours_text = f" - Estimativa: {self.estimated_hours}h" if self.estimated_hours else ""

        return f"{self.get_status_icon()} {self.task_name}{hours_text}\n" \
               f"üìÖ Vencimento: {self.due_date.strftime('%d/%m/%Y √†s %H:%M')}\n" \
               f"üìä Status: {status_text}\n" \
               f"üéØ {priority_text}"


class AdvancedOutputParser:
    """Classe avan√ßada para demonstrar OutputParsers com LangChain"""

    def __init__(self, use_langchain=True):
        self.use_langchain = use_langchain and LANGCHAIN_AVAILABLE

        if self.use_langchain:
            # Configura√ß√£o do LangChain
            self.llm = ChatOpenAI(model="gpt-4.1", temperature=0)

            # Parsers
            self.event_parser = PydanticOutputParser(pydantic_object=EventInfo)
            self.sentiment_parser = PydanticOutputParser(pydantic_object=SentimentAnalysis)
            self.appointment_parser = PydanticOutputParser(pydantic_object=AppointmentAnalysis)
            self.task_parser = PydanticOutputParser(pydantic_object=TaskInfo)

            # Templates
            self.event_template = ChatPromptTemplate.from_messages([
                ("system", "Voc√™ √© um assistente especializado em extrair informa√ß√µes de eventos e datas."),
                ("human", "Extraia as informa√ß√µes do evento do seguinte texto:\n{format_instructions}\n\nTexto: {text}")
            ])

            self.sentiment_template = ChatPromptTemplate.from_messages([
                ("system", "Voc√™ √© um especialista em an√°lise de sentimento. Analise o texto fornecido."),
                ("human", "Analise o sentimento do seguinte texto:\n{format_instructions}\n\nTexto: {text}")
            ])

            self.appointment_template = ChatPromptTemplate.from_messages([
                ("system", "Voc√™ √© um assistente especializado em an√°lise de compromissos e agenda."),
                ("human", "Analise o seguinte compromisso:\n{format_instructions}\n\nTexto: {text}")
            ])

            self.task_template = ChatPromptTemplate.from_messages([
                ("system", "Voc√™ √© um assistente de gerenciamento de tarefas. Analise as informa√ß√µes fornecidas."),
                ("human", "Analise a seguinte tarefa:\n{format_instructions}\n\nTexto: {text}")
            ])

            # Chains
            self.event_chain = self.event_template | self.llm | self.event_parser
            self.sentiment_chain = self.sentiment_template | self.llm | self.sentiment_parser
            self.appointment_chain = self.appointment_template | self.llm | self.appointment_parser
            self.task_chain = self.task_template | self.llm | self.task_parser
        else:
            print("üîß Executando em modo simulado (sem LangChain)")

    def parse_event_safe(self, text: str) -> EventInfo | None:
        """Parse seguro de evento com tratamento de erro"""
        try:
            if self.use_langchain:
                return self.event_chain.invoke({
                    "text": text,
                    "format_instructions": self.event_parser.get_format_instructions()
                })
            # Simula√ß√£o para demonstra√ß√£o
            return self._simulate_event_parse(text)
        except Exception as e:
            print(f"‚ùå Erro ao processar evento: {e}")
            return None

    def parse_sentiment_safe(self, text: str) -> SentimentAnalysis | None:
        """Parse seguro de sentimento com tratamento de erro"""
        try:
            if self.use_langchain:
                return self.sentiment_chain.invoke({
                    "text": text,
                    "format_instructions": self.sentiment_parser.get_format_instructions()
                })
            # Simula√ß√£o para demonstra√ß√£o
            return self._simulate_sentiment_parse(text)
        except Exception as e:
            print(f"‚ùå Erro ao processar sentimento: {e}")
            return None

    def parse_appointment_safe(self, text: str) -> AppointmentAnalysis | None:
        """Parse seguro de compromisso com tratamento de erro"""
        try:
            if self.use_langchain:
                return self.appointment_chain.invoke({
                    "text": text,
                    "format_instructions": self.appointment_parser.get_format_instructions()
                })
            # Simula√ß√£o para demonstra√ß√£o
            return self._simulate_appointment_parse(text)
        except Exception as e:
            print(f"‚ùå Erro ao processar compromisso: {e}")
            return None

    def parse_task_safe(self, text: str) -> TaskInfo | None:
        """Parse seguro de tarefa com tratamento de erro"""
        try:
            if self.use_langchain:
                return self.task_chain.invoke({
                    "text": text,
                    "format_instructions": self.task_parser.get_format_instructions()
                })
            # Simula√ß√£o para demonstra√ß√£o
            return self._simulate_task_parse(text)
        except Exception as e:
            print(f"‚ùå Erro ao processar tarefa: {e}")
            return None

    def _simulate_event_parse(self, text: str) -> EventInfo:
        """Simula parsing de evento"""
        tomorrow = datetime.now() + timedelta(days=1)

        if "reuni√£o" in text.lower():
            return EventInfo(
                event_name="Reuni√£o de Equipe",
                event_date=tomorrow.replace(hour=14, minute=30),
                duration_hours=2.0,
                is_recurring=False
            )
        return EventInfo(
            event_name="Evento Padr√£o",
            event_date=tomorrow.replace(hour=10, minute=0),
            duration_hours=1.0,
            is_recurring=False
        )

    def _simulate_sentiment_parse(self, text: str) -> SentimentAnalysis:
        """Simula parsing de sentimento"""
        is_positive = any(word in text.lower() for word in ["adorei", "perfeito", "excelente"])
        is_negative = any(word in text.lower() for word in ["quebrado", "urgente", "problema"])
        is_neutral = not (is_positive or is_negative)
        contains_urgency = "urgente" in text.lower()

        return SentimentAnalysis(
            text=text,
            is_positive=is_positive,
            is_negative=is_negative,
            is_neutral=is_neutral,
            contains_urgency=contains_urgency,
            confidence_score=0.8
        )

    def _simulate_appointment_parse(self, text: str) -> AppointmentAnalysis:
        """Simula parsing de compromisso"""
        tomorrow = datetime.now() + timedelta(days=1)

        return AppointmentAnalysis(
            appointment_date=tomorrow.replace(hour=10, minute=0),
            is_urgent="urgente" in text.lower(),
            is_important="importante" in text.lower(),
            requires_preparation="preparar" in text.lower(),
            is_online="online" in text.lower(),
            duration_minutes=60
        )

    def _simulate_task_parse(self, text: str) -> TaskInfo:
        """Simula parsing de tarefa"""
        tomorrow = datetime.now() + timedelta(days=1)

        return TaskInfo(
            task_name="Tarefa Padr√£o",
            due_date=tomorrow.replace(hour=18, minute=0),
            is_completed=False,
            is_high_priority="alta prioridade" in text.lower(),
            estimated_hours=2.0
        )


def demo_advanced_parsers():
    """Demonstra parsers avan√ßados com tratamento de erro"""
    print("üéØ EXEMPLO AVAN√áADO: OutputParsers com Tratamento de Erro")
    print("=" * 60)

    parser = AdvancedOutputParser(use_langchain=False)  # Simulado para demonstra√ß√£o

    # Teste com diferentes tipos de entrada
    test_cases = [
        "Reuni√£o de equipe amanh√£ √†s 14:30 por 2 horas",
        "Adorei o produto! Funciona perfeitamente.",
        "Reuni√£o URGENTE com o cliente amanh√£ √†s 10h. √â muito importante.",
        "Relat√≥rio mensal - vencimento: 15/12/2024 √†s 18h - alta prioridade"
    ]

    for i, text in enumerate(test_cases, 1):
        print(f"\nüìã Teste {i}: {text}")
        print("-" * 40)

        # Testa diferentes parsers
        event = parser.parse_event_safe(text)
        if event:
            print("üìÖ Evento:", event.display_info())

        sentiment = parser.parse_sentiment_safe(text)
        if sentiment:
            print("üòä Sentimento:", sentiment.get_sentiment_label())

        appointment = parser.parse_appointment_safe(text)
        if appointment:
            print("üìã Compromisso:", appointment.get_priority_level())

        task = parser.parse_task_safe(text)
        if task:
            print("‚úÖ Tarefa:", task.get_status_icon(), task.task_name)

        print("-" * 40)


def demo_error_handling():
    """Demonstra tratamento de erros em OutputParsers"""
    print("\nüéØ EXEMPLO: Tratamento de Erros")
    print("=" * 60)

    # Testa valida√ß√£o de data passada
    try:
        past_date = datetime.now() - timedelta(days=1)
        event = EventInfo(
            event_name="Evento Passado",
            event_date=past_date,
            duration_hours=1.0,
            is_recurring=False
        )
    except ValueError as e:
        print(f"‚ùå Valida√ß√£o funcionou: {e}")

    # Testa valida√ß√£o de confian√ßa
    try:
        sentiment = SentimentAnalysis(
            text="Teste",
            is_positive=True,
            is_negative=False,
            is_neutral=False,
            contains_urgency=False,
            confidence_score=1.5  # Inv√°lido: > 1.0
        )
    except ValueError as e:
        print(f"‚ùå Valida√ß√£o funcionou: {e}")

    # Testa valida√ß√£o de string vazia
    try:
        task = TaskInfo(
            task_name="",  # Inv√°lido: string vazia
            due_date=datetime.now() + timedelta(days=1),
            is_completed=False,
            is_high_priority=False
        )
    except ValueError as e:
        print(f"‚ùå Valida√ß√£o funcionou: {e}")


def main():
    """Fun√ß√£o principal"""
    print("üöÄ OUTPUTPARSERS AVAN√áADOS - EXEMPLOS PR√ÅTICOS")
    print("=" * 60)

    demo_advanced_parsers()
    demo_error_handling()

    print("\nüìö CONCEITOS AVAN√áADOS")
    print("=" * 60)
    print("""
üéØ Tratamento de Erros:
- Valida√ß√£o autom√°tica com Pydantic
- Try/catch para falhas de parsing
- Fallbacks para dados inv√°lidos

üéØ Valida√ß√£o Customizada:
- Validators para regras espec√≠ficas
- Valida√ß√£o de relacionamentos entre campos
- Mensagens de erro personalizadas

üéØ Type Safety:
- Verifica√ß√£o de tipos em tempo de execu√ß√£o
- Documenta√ß√£o autom√°tica dos campos
- Integra√ß√£o com IDEs

üéØ Casos de Uso Reais:
- APIs com respostas estruturadas
- Bancos de dados com schemas
- Sistemas de valida√ß√£o de dados
    """)


if __name__ == "__main__":
    main()
